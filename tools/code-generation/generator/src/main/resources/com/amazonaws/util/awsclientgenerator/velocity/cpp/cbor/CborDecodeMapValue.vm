auto key = decoder->PopNextTextVal();
if (key.has_value()) {
    Aws::String keyStr = Aws::String(reinterpret_cast<const char*>(key.value().ptr), key.value().len);
#if($shapeMember.enum)
    auto ${containerVar} = decoder->PopNextTextVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = ${shapeMember.name}Mapper::Get${shapeMember.name}ForName(Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len));
    }
#elseif($shapeMember.string)
if (decoder->PeekType().value() == Aws::Crt::Cbor::CborType::Text) {
    auto ${containerVar} = decoder->PopNextTextVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len);
    }
} else {
    decoder->ConsumeNextSingleElement();
    Aws::StringStream ss_${recursionDepth};
    while (decoder->LastError() == AWS_ERROR_UNKNOWN) {
        auto nextType_${recursionDepth} = decoder->PeekType();
        if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break) {
            if (nextType_${recursionDepth}.has_value()) {
                decoder->ConsumeNextSingleElement();  // consume the Break
            }
            break;
        }
        auto ${containerVar} = decoder->PopNextTextVal();
        if (${containerVar}.has_value()) {
            ss_${recursionDepth} << Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len);
        }
    }
        ${value}[keyStr] = ss_${recursionDepth}.str();
        ss_${recursionDepth}.clear();
    }
#elseif($shapeMember.boolean)
    auto ${containerVar} = decoder->PopNextBooleanVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = ${containerVar}.value();
    }
#elseif($shapeMember.double)
    auto ${containerVar} = decoder->PopNextFloatVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = ${containerVar}.value();
    }
#elseif($shapeMember.float)
    auto ${containerVar} = decoder->PopNextFloatVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = ${containerVar}.value();
    }
#elseif($shapeMember.blob)
    if (decoder->PeekType().value() == Aws::Crt::Cbor::CborType::IndefBytesStart){
        decoder->ConsumeNextSingleElement();
    }
    auto ${containerVar} = decoder->PopNextBytesVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = Aws::Utils::ByteBuffer(${containerVar}.value().ptr, ${containerVar}.value().len);
    }
#elseif($shapeMember.timeStamp)
    auto tag = decoder->PopNextTagVal();
    if (tag.has_value() && tag.value() == 1) //1 represents Epoch-based date/time. See https://www.rfc-editor.org/rfc/rfc8949.html#tags
    {
        auto dateType = decoder->PeekType();
        if (dateType.has_value())
        {
            if (dateType.value() == Aws::Crt::Cbor::CborType::Float)
            {
                auto ${containerVar} = decoder->PopNextFloatVal();
                if (${containerVar}.has_value()) {
                    ${value}[keyStr] = Aws::Utils::DateTime(${containerVar}.value());
                }
            }
            else if (dateType.value() == Aws::Crt::Cbor::CborType::UInt)
            {
                auto ${containerVar} = decoder->PopNextUnsignedIntVal();
                if (${containerVar}.has_value()) {
                    ${value}[keyStr] = Aws::Utils::DateTime(${containerVar}.value());
                }
            }
            else
            {
                auto ${containerVar} = decoder->PopNextNegativeIntVal();
                if (${containerVar}.has_value())
                {
                    ${value}[keyStr] = Aws::Utils::DateTime(${containerVar}.value());
                }
            }
        }
    }
#elseif($shapeMember.structure)
    #if($shapeMember.isMutuallyReferencedWith($shape) || $shapeMember.getName() == $shape.getName())
        ${value}[keyStr] = Aws::MakeShared<${shapeMember.name}>("${typeInfo.className}", ${shapeMember.name}(decoder));
    #else
        ${value}[keyStr] = ${shapeMember.name}(decoder);
    #end
#elseif($shapeMember.map)
    #set($shapeMember = $shapeMember.mapValue.shape)
    #set($recursionDepth = $recursionDepth + 1)
    #set($value = "nestedMap_${recursionDepth}")
    auto nestedMap_${recursionDepth} = Map<Aws::String, $CppViewHelper.computeCppType($shapeMember)>();
    auto peekType_${recursionDepth} = decoder->PeekType();
    if (peekType_${recursionDepth}.has_value() && (peekType_${recursionDepth}.value() == CborType::MapStart || peekType_${recursionDepth}.value() == CborType::IndefMapStart))
    {
      if (peekType_${recursionDepth}.value() == CborType::MapStart)
      {
        auto mapSize_${recursionDepth} = decoder->PopNextMapStart();
        if(mapSize_${recursionDepth}.has_value()){
        for (size_t j_${recursionDepth} = 0; j_${recursionDepth} < mapSize_${recursionDepth}.value(); j_${recursionDepth}++) {
        #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeMapValue.vm")
        }
        }
      }
      else // IndefMapStart
      {
        decoder->ConsumeNextSingleElement(); // consume the IndefMapStart
        while (decoder->LastError() == AWS_ERROR_UNKNOWN)
        {
          auto nextType_${recursionDepth} = decoder->PeekType();
          if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break)
          {
            if (nextType_${recursionDepth}.has_value())
            {
              decoder->ConsumeNextSingleElement(); // consume the Break
            }
            break;
          }
          #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeMapValue.vm")
        }
      }
      ${memberVarName}[keyStr] = ${value};
    }
#elseif($shapeMember.list)
    #set($shapeMember = $shapeMember.listMember.shape)
    #set($recursionDepth = $recursionDepth + 1)
    #set($value = "nestedList_${recursionDepth}")
    auto nestedList_${recursionDepth} = Vector<$CppViewHelper.computeCppType($shapeMember)>();
    auto peekType_${recursionDepth} = decoder->PeekType();
    if (peekType_${recursionDepth}.has_value() && (peekType_${recursionDepth}.value() == CborType::ArrayStart || peekType_${recursionDepth}.value() == CborType::IndefArrayStart))
    {
      if (peekType_${recursionDepth}.value() == CborType::ArrayStart)
      {
        auto listSize_${recursionDepth} = decoder->PopNextArrayStart();
        if(listSize_${recursionDepth}.has_value()){
        for (size_t j_${recursionDepth} = 0; j_${recursionDepth} < listSize_${recursionDepth}.value(); j_${recursionDepth}++) {
        #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeListValue.vm")
        }
        }
      }
      else // IndefArrayStart
      {
        decoder->ConsumeNextSingleElement(); // consume the IndefArrayStart
        while (decoder->LastError() == AWS_ERROR_UNKNOWN)
        {
          auto nextType_${recursionDepth} = decoder->PeekType();
          if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break)
          {
            if (nextType_${recursionDepth}.has_value())
            {
              decoder->ConsumeNextSingleElement(); // consume the Break
            }
            break;
          }
          #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeListValue.vm")
        }
      }
      ${memberVarName}[keyStr] = ${value};
    }
#else
    auto ${containerVar} = decoder->PeekType().value() == Aws::Crt::Cbor::CborType::UInt ? decoder->PopNextUnsignedIntVal() : decoder->PopNextNegativeIntVal();
    if (${containerVar}.has_value()) {
        ${value}[keyStr] = ${containerVar}.value();
    }
#end
}