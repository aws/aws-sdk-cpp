#set($signPayloadsOptional = true)
#set($virtualAddressingSupported = true)
#set($arnEndpointSupported = true)
#set($vpcEndpointSupported = true)
#set($multiRegionAccessPointSupported = true)
#set($serviceNamespace = $serviceModel.metadata.namespace)
#set($USEast1RegionalEndpointArgString = ", Aws::${serviceNamespace}::US_EAST_1_REGIONAL_ENDPOINT_OPTION USEast1RegionalEndPointOption")
#set($USEast1RegionalEndpointInitString = ", m_USEast1RegionalEndpointOption(USEast1RegionalEndPointOption)")
#set($ForRegionExtraArgsString = ", m_USEast1RegionalEndpointOption == Aws::${serviceNamespace}::US_EAST_1_REGIONAL_ENDPOINT_OPTION::REGIONAL")
#parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/xml/rest/RestXmlServiceClientSource.vm")

#if(!${onlyGeneratedOperations})

#set($clsWSpace = $className.replaceAll(".", " "))
\#include<aws/core/utils/HashingUtils.h>
Aws::String ${className}::GeneratePresignedUrl(const Aws::String& bucket,
            ${clsWSpace}                       const Aws::String& key,
            ${clsWSpace}                       Aws::Http::HttpMethod method,
            ${clsWSpace}                       uint64_t expirationInSeconds)
{
    return GeneratePresignedUrl(bucket, key, method, {}, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrl(const Aws::String& bucket,
            ${clsWSpace}                       const Aws::String& key,
            ${clsWSpace}                       Aws::Http::HttpMethod method,
            ${clsWSpace}                       const Http::HeaderValueCollection& customizedHeaders,
            ${clsWSpace}                       uint64_t expirationInSeconds)
{
    if (!m_endpointProvider)
    {
        AWS_LOGSTREAM_ERROR(ALLOCATION_TAG, "Presigned URL generating failed. Endpoint provider is not initialized.");
        return {};
    }
    ResolveEndpointOutcome computeEndpointOutcome = m_endpointProvider->ResolveEndpoint({{Aws::String("Bucket"), bucket}});
    if (!computeEndpointOutcome.IsSuccess())
    {
        AWS_LOGSTREAM_ERROR(ALLOCATION_TAG, "Presigned URL generating failed. Encountered error: " << computeEndpointOutcome.GetError().GetMessage());
        return {};
    }
    Aws::Endpoint::AWSEndpoint& endpoint = computeEndpointOutcome.GetResult();
    endpoint.AddPathSegments(key);
    Aws::Map<Aws::String, Aws::String> params;
    params.emplace("bucketName", bucket);
    ServiceSpecificParameters serviceSpecificParameters{params};
    auto serviceParams = Aws::MakeShared<ServiceSpecificParameters>(ALLOCATION_TAG, serviceSpecificParameters);
    return AWSClient::GeneratePresignedUrl(endpoint, method, customizedHeaders, expirationInSeconds, Aws::Auth::SIGV4_SIGNER,
        nullptr, nullptr, serviceParams);
}

Aws::String ${className}::GeneratePresignedUrlWithSSES3(const Aws::String& bucket,
            ${clsWSpace}                                const Aws::String& key,
            ${clsWSpace}                                Aws::Http::HttpMethod method,
            ${clsWSpace}                                uint64_t expirationInSeconds)
{
    Aws::Http::HeaderValueCollection headers;
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::AES256));
    return GeneratePresignedUrl(bucket, key, method, headers, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrlWithSSES3(const Aws::String& bucket,
            ${clsWSpace}                                const Aws::String& key,
            ${clsWSpace}                                Aws::Http::HttpMethod method,
            ${clsWSpace}                                Http::HeaderValueCollection customizedHeaders,
            ${clsWSpace}                                uint64_t expirationInSeconds)
{
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::AES256));
    return GeneratePresignedUrl(bucket, key, method, customizedHeaders, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrlWithSSEKMS(const Aws::String& bucket,
            ${clsWSpace}                                 const Aws::String& key,
            ${clsWSpace}                                 Aws::Http::HttpMethod method,
            ${clsWSpace}                                 const Aws::String& kmsMasterKeyId,
            ${clsWSpace}                                 uint64_t expirationInSeconds)
{
    Aws::Http::HeaderValueCollection headers;
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::aws_kms));
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, kmsMasterKeyId);
    return GeneratePresignedUrl(bucket, key, method, headers, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrlWithSSEKMS(const Aws::String& bucket,
            ${clsWSpace}                                 const Aws::String& key,
            ${clsWSpace}                                 Aws::Http::HttpMethod method,
            ${clsWSpace}                                 Http::HeaderValueCollection customizedHeaders,
            ${clsWSpace}                                 const Aws::String& kmsMasterKeyId,
            ${clsWSpace}                                 uint64_t expirationInSeconds)
{
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::aws_kms));
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_AWS_KMS_KEY_ID, kmsMasterKeyId);
    return GeneratePresignedUrl(bucket, key, method, customizedHeaders, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrlWithSSEC(const Aws::String& bucket,
            ${clsWSpace}                               const Aws::String& key,
            ${clsWSpace}                               Aws::Http::HttpMethod method,
            ${clsWSpace}                               const Aws::String& base64EncodedAES256Key,
            ${clsWSpace}                               uint64_t expirationInSeconds)
{
    Aws::Http::HeaderValueCollection headers;
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::AES256));
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY, base64EncodedAES256Key);
    Aws::Utils::ByteBuffer buffer = Aws::Utils::HashingUtils::Base64Decode(base64EncodedAES256Key);
    Aws::String strBuffer(reinterpret_cast<char*>(buffer.GetUnderlyingData()), buffer.GetLength());
    headers.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, Aws::Utils::HashingUtils::Base64Encode(Aws::Utils::HashingUtils::CalculateMD5(strBuffer)));
    return GeneratePresignedUrl(bucket, key, method, headers, expirationInSeconds);
}

Aws::String ${className}::GeneratePresignedUrlWithSSEC(const Aws::String& bucket,
            ${clsWSpace}                               const Aws::String& key,
            ${clsWSpace}                               Aws::Http::HttpMethod method,
            ${clsWSpace}                               Http::HeaderValueCollection customizedHeaders,
            ${clsWSpace}                               const Aws::String& base64EncodedAES256Key,
            ${clsWSpace}                               uint64_t expirationInSeconds)
{
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_ALGORITHM, Aws::${serviceNamespace}::Model::ServerSideEncryptionMapper::GetNameForServerSideEncryption(Aws::${serviceNamespace}::Model::ServerSideEncryption::AES256));
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY, base64EncodedAES256Key);
    Aws::Utils::ByteBuffer buffer = Aws::Utils::HashingUtils::Base64Decode(base64EncodedAES256Key);
    Aws::String strBuffer(reinterpret_cast<char*>(buffer.GetUnderlyingData()), buffer.GetLength());
    customizedHeaders.emplace(Aws::${serviceNamespace}::SSEHeaders::SERVER_SIDE_ENCRYPTION_CUSTOMER_KEY_MD5, Aws::Utils::HashingUtils::Base64Encode(Aws::Utils::HashingUtils::CalculateMD5(strBuffer)));
    return GeneratePresignedUrl(bucket, key, method, customizedHeaders, expirationInSeconds);
}


bool ${className}::MultipartUploadSupported() const
{
    return true;
}
#end
