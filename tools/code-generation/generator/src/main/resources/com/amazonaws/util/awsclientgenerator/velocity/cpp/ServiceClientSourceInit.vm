#if(!${onlyGeneratedOperations})
#set($additionalCtorSignatureArgs = {})
#set($ctorMemberInitList = [])
#set($addArgDummy = $ctorMemberInitList.add("m_clientConfiguration(clientConfiguration)"))
#set($signerCtorArgs = [])
#set($additionalCtorArgs = {})
#if($signPayloadsOptional)
#set($addArgDummy = $signerCtorArgs.add("clientConfiguration.payloadSigningPolicy"))
#else
#set($signPayloads = "")
#set($signPayloadsParam = "")
#end
#if($metadata.signatureVersion.equals("s3") || $metadata.signatureVersion.equals("s3v4"))
#if(!$signPayloadsOptional)
#set($signPayloadsParam = ", Aws::Client::AWSAuthV4Signer::PayloadSigningPolicy::RequestDependent")
#set($addArgDummy = $signerCtorArgs.add("Aws::Client::AWSAuthV4Signer::PayloadSigningPolicy::RequestDependent"))
#end
#set($doubleEncodeValue = ", false")
#set($addArgDummy = $signerCtorArgs.add("/*doubleEncodeValue*/ false"))
#else
#set($doubleEncodeValue = "")
#end
#if($virtualAddressingSupported)
#else
#set($virtualAddressing = "")
#set($virtualAddressingInit = "")
#end
#set($endpointsProviderDefaultCtorCall = "m_endpointProvider(endpointProvider ? std::move(endpointProvider) : Aws::MakeShared<" + ${metadata.classNamePrefix} + "EndpointProvider>(ALLOCATION_TAG))")
#set($addArgDummy = $ctorMemberInitList.add($endpointsProviderDefaultCtorCall))
#if(!$USEast1RegionalEndpointArgString)
#set($USEast1RegionalEndpointArgString = "")
#else
#end
#if(!$USEast1RegionalEndpointInitString)
#set($USEast1RegionalEndpointInitString = "")
#else
#end
#if(!$ForRegionExtraArgsString)
#set($ForRegionExtraArgsString = "")##single place in m_baseUri assignment-init
#end
#set($clientConfigurationNamespace = "Client")
#set($defaultCredentialsProviderChainParam = "Aws::MakeShared<DefaultAWSCredentialsProviderChain>(ALLOCATION_TAG)")
#set($s3ExpressIdentityProviderParam = "clientConfiguration.identityProviderSupplier(*this)")
#set($simpleCredentialsProviderParam = "Aws::MakeShared<SimpleAWSCredentialsProvider>(ALLOCATION_TAG, credentials)")
#set($hasEventStreamInputOperation = $serviceModel.hasStreamingRequestShapes())
#set($signerToMake = "AWSAuthV4Signer")
#if($metadata.projectName == "s3")
#set($signerToMake = "Aws::Auth::S3ExpressSignerProvider")
#elseif($serviceModel.hasOnlyBearerAuth())
#set($signerToMake = "Aws::Auth::BearerTokenAuthSignerProvider")
#elseif($hasEventStreamInputOperation || $multiRegionAccessPointSupported)
#set($signerToMake = "Aws::Auth::DefaultAuthSignerProvider")
#end
#set($clientConfigurationCls = ${serviceNamespace} + "::" + ${metadata.classNamePrefix} + "ClientConfiguration")
#set($clsWSpace = $className.replaceAll(".", " "))
#set($signerWSpace = $signerToMake.replaceAll(".", " "))
#if($serviceNamespace == "S3")
${className}::${className}(const ${className} &rhs) :
    BASECLASS(rhs.m_clientConfiguration,
        Aws::MakeShared<${signerToMake}>(ALLOCATION_TAG,
            rhs.GetCredentialsProvider(),
            rhs.m_clientConfiguration.identityProviderSupplier(*this),
            SERVICE_NAME,
            Aws::Region::ComputeSignerRegion(rhs.m_clientConfiguration.region),
            rhs.m_clientConfiguration.payloadSigningPolicy,
            /*doubleEncodeValue*/ false),
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
            Aws::Client::ClientWithAsyncTemplateMethods<${className}>(),
    m_clientConfiguration(rhs.m_clientConfiguration),
    m_endpointProvider(rhs.m_endpointProvider) {}

${className}& ${className}::operator=(const ${className} &rhs) {
    if (&rhs == this) {
      return *this;
    }
    BASECLASS::operator=(rhs);
    m_signerProvider = Aws::MakeShared<Aws::Auth::S3ExpressSignerProvider>(ALLOCATION_TAG,
          rhs.GetCredentialsProvider(),
          rhs.m_clientConfiguration.identityProviderSupplier(*this),
          SERVICE_NAME,
          Aws::Region::ComputeSignerRegion(rhs.m_clientConfiguration.region),
          rhs.m_clientConfiguration.payloadSigningPolicy,
          /*doubleEncodeValue*/ false);
    m_clientConfiguration = rhs.m_clientConfiguration;
    m_endpointProvider = rhs.m_endpointProvider;
    init(m_clientConfiguration);
    return *this;
}

S3Client::S3Client(${className} &&rhs) noexcept :
    BASECLASS(rhs.m_clientConfiguration,
        Aws::MakeShared<Aws::Auth::S3ExpressSignerProvider>(ALLOCATION_TAG,
            rhs.GetCredentialsProvider(),
            rhs.m_clientConfiguration.identityProviderSupplier(*this),
            SERVICE_NAME,
            Aws::Region::ComputeSignerRegion(rhs.m_clientConfiguration.region),
            rhs.m_clientConfiguration.payloadSigningPolicy,
            /*doubleEncodeValue*/ false),
            Aws::MakeShared<S3ErrorMarshaller>(ALLOCATION_TAG)),
            Aws::Client::ClientWithAsyncTemplateMethods<S3Client>(),
    m_clientConfiguration(std::move(rhs.m_clientConfiguration)),
    m_endpointProvider(std::move(rhs.m_endpointProvider)) {}

${className}& ${className}::operator=(${className} &&rhs) noexcept {
  if (&rhs == this) {
    return *this;
  }
  BASECLASS::operator=(std::move(rhs));
  m_signerProvider = Aws::MakeShared<Aws::Auth::S3ExpressSignerProvider>(ALLOCATION_TAG,
        rhs.GetCredentialsProvider(),
        rhs.m_clientConfiguration.identityProviderSupplier(*this),
        SERVICE_NAME,
        Aws::Region::ComputeSignerRegion(rhs.m_clientConfiguration.region),
        rhs.m_clientConfiguration.payloadSigningPolicy,
        /*doubleEncodeValue*/ false);
  m_clientConfiguration = std::move(rhs.m_clientConfiguration);
  m_endpointProvider = std::move(rhs.m_endpointProvider);
  init(m_clientConfiguration);
  return *this;
}

#end
#if($serviceModel.hasOnlyBearerAuth())
##BEARER TOKEN AUTH PROVIDER C-TOR
#set($bearerAddCtorArgs = {})
#foreach ($ctorKey in ["signPayloads", "useVirtualAddressing", "USEast1RegionalEndpoint"])
#if($additionalCtorArgs.containsKey($ctorKey))#set($addArgDummy = $bearerAddCtorArgs.put($ctorKey, $additionalCtorArgs.get($ctorKey)))#end
#end
    ${className}::${className}(const ${signerToMake}& bearerTokenProvider,
    ${clsWSpace}  ${clsWSpace} std::shared_ptr<${metadata.classNamePrefix}EndpointProviderBase> endpointProvider,
    ${clsWSpace}  ${clsWSpace} const ${clientConfigurationCls}& clientConfiguration#if($bearerAddCtorArgs.isEmpty())) :#else,#end
#foreach($ctorArgument in $bearerAddCtorArgs)
    ${clsWSpace}  ${clsWSpace} ${ctorArgument}#if( $foreach.hasNext ),#else) :#end

#end
  BASECLASS(clientConfiguration,
            Aws::MakeShared<${signerToMake}>(ALLOCATION_TAG, bearerTokenProvider),
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
#foreach($ctorMemberInit in $ctorMemberInitList)
  ${ctorMemberInit}#if( $foreach.hasNext ),

#else#end
#end
{
  init(m_clientConfiguration);
}
## END OF BEARER TOKEN AUTH PROVIDER C-TOR

#else##!#if($serviceModel.hasOnlyBearerAuth())
##DEFAULT CREDENTIALS PROVIDER C-TOR
#set($defCredsChainCtor = {})
#foreach ($ctorKey in ["signPayloads", "useVirtualAddressing", "USEast1RegionalEndpoint"])
#if($additionalCtorArgs.containsKey($ctorKey))#set($addArgDummy = $defCredsChainCtor.put($ctorKey, $additionalCtorArgs.get($ctorKey)))#end
#end
${className}::${className}(const ${clientConfigurationCls}& clientConfiguration,
${clsWSpace}  ${clsWSpace} std::shared_ptr<${metadata.classNamePrefix}EndpointProviderBase> endpointProvider#if($defCredsChainCtor.isEmpty())) :#else,#end

#foreach($ctorArgument in $defCredsChainCtor)
${clsWSpace}  ${clsWSpace} ${ctorArgument}#if( $foreach.hasNext ),#else) :#end

#end
  BASECLASS(clientConfiguration,
            Aws::MakeShared<${signerToMake}>(ALLOCATION_TAG,
                            ${signerWSpace}  ${defaultCredentialsProviderChainParam},
#if($metadata.projectName == "s3")
                            ${signerWSpace}  ${s3ExpressIdentityProviderParam},
#end
                            ${signerWSpace}  SERVICE_NAME,
                            ${signerWSpace}  Aws::Region::ComputeSignerRegion(clientConfiguration.region)#if($signerCtorArgs.isEmpty())#else,
#end
#foreach($signerCtorArg in $signerCtorArgs)
                            ${signerWSpace}  ${signerCtorArg}#if( $foreach.hasNext ),
#else#end
#end),
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
#foreach($ctorMemberInit in $ctorMemberInitList)
  ${ctorMemberInit}#if( $foreach.hasNext ),
#else#end
#end

{
  init(m_clientConfiguration);
}
##END OF DEFAULT CREDENTIALS PROVIDER C-TOR

##SIMPLE CREDENTIALS PROVIDER C-TOR
#set($simpleCredsCtor = {})
#foreach ($ctorKey in ["signPayloads", "useVirtualAddressing", "USEast1RegionalEndpoint"])
#if($additionalCtorArgs.containsKey($ctorKey))#set($addArgDummy = $simpleCredsCtor.put($ctorKey, $additionalCtorArgs.get($ctorKey)))#end
#end
${className}::${className}(const AWSCredentials& credentials,
${clsWSpace}  ${clsWSpace} std::shared_ptr<${metadata.classNamePrefix}EndpointProviderBase> endpointProvider,
${clsWSpace}  ${clsWSpace} const ${clientConfigurationCls}& clientConfiguration#if($simpleCredsCtor.isEmpty())) :#else,#end

#foreach($ctorArgument in $simpleCredsCtor)
${clsWSpace}  ${clsWSpace} ${ctorArgument}#if( $foreach.hasNext ),#else) :#end

#end
  BASECLASS(clientConfiguration,
            Aws::MakeShared<${signerToMake}>(ALLOCATION_TAG,
                            ${signerWSpace}  ${simpleCredentialsProviderParam},
#if($metadata.projectName == "s3")
                            ${signerWSpace}  ${s3ExpressIdentityProviderParam},
#end
                            ${signerWSpace}  SERVICE_NAME,
                            ${signerWSpace}  Aws::Region::ComputeSignerRegion(clientConfiguration.region)#if($signerCtorArgs.isEmpty())#else,
#end
#foreach($signerCtorArg in $signerCtorArgs)
                            ${signerWSpace}  ${signerCtorArg}#if( $foreach.hasNext ),
#else#end
#end),
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
#foreach($ctorMemberInit in $ctorMemberInitList)
    ${ctorMemberInit}#if( $foreach.hasNext ),
#else#end
#end

{
  init(m_clientConfiguration);
}
##END OF SIMPLE CREDENTIALS PROVIDER C-TOR

##SPECIFIED CREDENTIALS PROVIDER C-TOR
#set($specCredsCtor = {})
#foreach ($ctorKey in ["signPayloads", "useVirtualAddressing", "USEast1RegionalEndpoint"])
#if($additionalCtorArgs.containsKey($ctorKey))#set($addArgDummy = $specCredsCtor.put($ctorKey, $additionalCtorArgs.get($ctorKey)))#end
#end
${className}::${className}(const std::shared_ptr<AWSCredentialsProvider>& credentialsProvider,
${clsWSpace}  ${clsWSpace} std::shared_ptr<${metadata.classNamePrefix}EndpointProviderBase> endpointProvider,
${clsWSpace}  ${clsWSpace} const ${clientConfigurationCls}& clientConfiguration#if($specCredsCtor.isEmpty())) :#else,#end

#foreach($ctorArgument in $specCredsCtor)
${clsWSpace}  ${clsWSpace} ${ctorArgument}#if( $foreach.hasNext ),#else) :#end

#end
  BASECLASS(clientConfiguration,
            Aws::MakeShared<${signerToMake}>(ALLOCATION_TAG,
                            ${signerWSpace}  credentialsProvider,
#if($metadata.projectName == "s3")
                            ${signerWSpace}  ${s3ExpressIdentityProviderParam},
#end
                            ${signerWSpace}  SERVICE_NAME,
                            ${signerWSpace}  Aws::Region::ComputeSignerRegion(clientConfiguration.region)#if($signerCtorArgs.isEmpty())#else,
#end
#foreach($signerCtorArg in $signerCtorArgs)
                            ${signerWSpace}  ${signerCtorArg}#if( $foreach.hasNext ),
#else#end
#end),
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
#foreach($ctorMemberInit in $ctorMemberInitList)
    ${ctorMemberInit}#if( $foreach.hasNext ),
#else#end
#end

{
  init(m_clientConfiguration);
}
##END OF SPECIFIED CREDENTIALS PROVIDER C-TOR
#end##if($serviceModel.hasOnlyBearerAuth())

#if($metadata.standalone || $metadata.apigateway)
#set($standaloneCredsCtor = {})
#foreach ($ctorKey in ["signPayloads", "useVirtualAddressing", "USEast1RegionalEndpoint"])
#if($additionalCtorArgs.containsKey($ctorKey))#set($addArgDummy = $standaloneCredsCtor.put($ctorKey, $additionalCtorArgs.get($ctorKey)))#end
#end
${className}::${className}(const std::shared_ptr<Aws::Auth::AWSAuthSignerProvider>& signerProvider,
${clsWSpace}  ${clsWSpace} const ${clientConfigurationCls}& clientConfiguration#if($standaloneCredsCtor.isEmpty())) :#else,#end

#foreach($ctorArgument in $specCredsCtor)
${clsWSpace}  ${clsWSpace} ${ctorArgument}#if( $foreach.hasNext ),#else) :#end

#end
  BASECLASS(clientConfiguration,
            signerProvider,
            Aws::MakeShared<${metadata.classNamePrefix}ErrorMarshaller>(ALLOCATION_TAG)),
${virtualAddressingInit}
{
  init(m_clientConfiguration);
}

#end
    /* Legacy constructors due deprecation */
  #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/ServiceClientSourceLegacyConstructors.vm")
    /* End of legacy constructors due deprecation */
${className}::~${className}()
{
  ShutdownSdkClient(this, -1);
}

std::shared_ptr<${metadata.classNamePrefix}EndpointProviderBase>& ${className}::accessEndpointProvider()
{
  return m_endpointProvider;
}

void ${className}::init(const ${clientConfigurationCls}& config)
{
  AWSClient::SetServiceClientName("${metadata.serviceId}");
  if (!m_clientConfiguration.executor) {
    if (!m_clientConfiguration.configFactories.executorCreateFn()) {
      AWS_LOGSTREAM_FATAL(ALLOCATION_TAG, "Failed to initialize client: config is missing Executor or executorCreateFn");
      m_isInitialized = false;
      return;
    }
    m_clientConfiguration.executor = m_clientConfiguration.configFactories.executorCreateFn();
  }
  AWS_CHECK_PTR(SERVICE_NAME, m_endpointProvider);
  m_endpointProvider->InitBuiltInParameters(config);
#if($AdditionalServiceSpecificConfigLoadString)
  ${AdditionalServiceSpecificConfigLoadString}
#end##if($AdditionalServiceSpecificConfigLoadString)
}

void ${className}::OverrideEndpoint(const Aws::String& endpoint)
{
  AWS_CHECK_PTR(SERVICE_NAME, m_endpointProvider);
  m_endpointProvider->OverrideEndpoint(endpoint);
}
#end
