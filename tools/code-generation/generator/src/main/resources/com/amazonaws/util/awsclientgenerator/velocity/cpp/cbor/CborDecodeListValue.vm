#if($shapeMember.enum)
auto ${containerVar} = decoder->PopNextTextVal();
if (${containerVar}.has_value()) {
    ${value}.push_back(${shapeMember.name}Mapper::Get${shapeMember.name}ForName(Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len)));
    }
#elseif($shapeMember.string)
auto peekType_${recursionDepth} = decoder->PeekType();
if(peekType_${recursionDepth}.has_value()){
    if (peekType_${recursionDepth}.value() == Aws::Crt::Cbor::CborType::Text) {
        auto ${containerVar} = decoder->PopNextTextVal();
        if (${containerVar}.has_value()) {
            ${value}.push_back(Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len));
        }
    } else {
        decoder->ConsumeNextSingleElement();
        Aws::StringStream ss_${recursionDepth};
        while (decoder->LastError() == AWS_ERROR_UNKNOWN) {
            auto nextType_${recursionDepth} = decoder->PeekType();
            if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break) {
                if (nextType_${recursionDepth}.has_value()) {
                    decoder->ConsumeNextSingleElement();  // consume the Break
                }
                break;
            }
            auto ${containerVar} = decoder->PopNextTextVal();
            if (${containerVar}.has_value()) {
                ss_${recursionDepth} << Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len);
            }
        }
        ${value}.push_back(ss_${recursionDepth}.str());
        ss_${recursionDepth}.clear();
    }
}
#elseif($shapeMember.boolean)
    auto ${containerVar} = decoder->PopNextBooleanVal();
    if (${containerVar}.has_value()) {
    ${value}.push_back(${containerVar}.value());
    }
#elseif($shapeMember.double)
    auto ${containerVar} = decoder->PopNextFloatVal();
    if (${containerVar}.has_value()) {
    ${value}.push_back(${containerVar}.value());
    }
#elseif($shapeMember.float)
    auto ${containerVar} = decoder->PopNextFloatVal();
    if (${containerVar}.has_value()) {
    ${value}.push_back(${containerVar}.value());
    }
#elseif($shapeMember.blob)
    auto peekType_${recursionDepth} = decoder->PeekType();
    if (peekType_${recursionDepth}.has_value()){
        if (peekType_${recursionDepth}.value() == Aws::Crt::Cbor::CborType::Bytes) {
            auto ${containerVar} = decoder->PopNextBytesVal();
            if (${containerVar}.has_value()) {
                ${value}.push_back(Aws::Utils::ByteBuffer(${containerVar}.value().ptr, ${containerVar}.value().len));
            }
        } else {
            decoder->ConsumeNextSingleElement();
            Aws::StringStream ss_${recursionDepth};
            while (decoder->LastError() == AWS_ERROR_UNKNOWN) {
                auto nextType_${recursionDepth} = decoder->PeekType();
                if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break) {
                    if (nextType_${recursionDepth}.has_value()) {
                        decoder->ConsumeNextSingleElement();  // consume the Break
                    }
                    break;
                }
                auto ${containerVar} = decoder->PopNextBytesVal();
                if (${containerVar}.has_value()) {
                    ss_${recursionDepth} << Aws::String(reinterpret_cast<const char*>(${containerVar}.value().ptr), ${containerVar}.value().len);
                }
            }
            ${value}.push_back(ss_${recursionDepth}.str());
            ss_${recursionDepth}.clear();
        }
    }
#elseif($shapeMember.timeStamp)
    auto tag = decoder->PopNextTagVal();
    if (tag.has_value() && tag.value() == 1) //1 represents Epoch-based date/time. See https://www.rfc-editor.org/rfc/rfc8949.html#tags
    {
        auto dateType = decoder->PeekType();
        if (dateType.has_value())
        {
            if (dateType.value() == Aws::Crt::Cbor::CborType::Float)
            {
                auto ${containerVar} = decoder->PopNextFloatVal();
                if (${containerVar}.has_value()) {
                    ${value}.push_back(Aws::Utils::DateTime(${containerVar}.value()));
                }
            }
            else
            {
                auto ${containerVar} = decoder->PopNextUnsignedIntVal();
                if (${containerVar}.has_value()) {
                    ${value}.push_back(Aws::Utils::DateTime(${containerVar}.value()));
                }
            }
        }
    }
#elseif($shapeMember.structure)
    #if($member.shape.isMutuallyReferencedWith($shape) || $member.shape.getName() == $shape.getName())
        ${value}.push_back(Aws::MakeShared<${shapeMember.name}>("${typeInfo.className}", ${shapeMember.name}(decoder)));
    #else
        ${value}.push_back(${shapeMember.name}(decoder));
    #end
#elseif($shapeMember.list)
    #set($template.nestedShapeMember = $shapeMember.listMember.shape)
    auto nestedList_${recursionDepth} = Vector<$CppViewHelper.computeCppType($template.nestedShapeMember)>();
    auto peekType_${recursionDepth} = decoder->PeekType();
    if (peekType_${recursionDepth}.has_value() && (peekType_${recursionDepth}.value() == CborType::ArrayStart || peekType_${recursionDepth}.value() == CborType::IndefArrayStart))
    {
      if (peekType_${recursionDepth}.value() == CborType::ArrayStart)
      {
        auto listSize_${recursionDepth} = decoder->PopNextArrayStart();
        if(listSize_${recursionDepth}.has_value()){
        for (size_t j_${recursionDepth} = 0; j_${recursionDepth} < listSize_${recursionDepth}.value(); j_${recursionDepth}++) {
        #set($value = "nestedList_${recursionDepth}")
        #set($recursionDepth = $recursionDepth + 1)
        #set($shapeMember = $template.nestedShapeMember)
        #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeListValue.vm")
        #set($recursionDepth = $recursionDepth - 1)
        }
        }
      }
      else // IndefArrayStart
      {
        decoder->ConsumeNextSingleElement(); // consume the IndefArrayStart
        while (decoder->LastError() == AWS_ERROR_UNKNOWN)
        {
          auto nextType_${recursionDepth} = decoder->PeekType();
          if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break)
          {
            if (nextType_${recursionDepth}.has_value())
            {
              decoder->ConsumeNextSingleElement(); // consume the Break
            }
            break;
          }
          #set($value = "nestedList_${recursionDepth}")
          #set($recursionDepth = $recursionDepth + 1)
          #set($shapeMember = $template.nestedShapeMember)
          #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeListValue.vm")
          #set($recursionDepth = $recursionDepth - 1)
        }
      }
      #if($recursionDepth > 1)
        #set($parentDepth = $recursionDepth - 1)
        nestedList_${parentDepth}.push_back(${value});
      #else
      ${memberVarName}.push_back(nestedList_${recursionDepth});
      #end
    }
#elseif($shapeMember.map)
    #set($template.nestedShapeMember = $shapeMember.mapValue.shape)
    auto nestedMap_${recursionDepth} = Map<Aws::String, $CppViewHelper.computeCppType($template.nestedShapeMember)>();
    auto peekType_${recursionDepth} = decoder->PeekType();
    if (peekType_${recursionDepth}.has_value() && (peekType_${recursionDepth}.value() == CborType::MapStart || peekType_${recursionDepth}.value() == CborType::IndefMapStart))
    {
      if (peekType_${recursionDepth}.value() == CborType::MapStart)
      {
        auto mapSize_${recursionDepth} = decoder->PopNextMapStart();
        for (size_t j_${recursionDepth} = 0; j_${recursionDepth} < mapSize_${recursionDepth}.value(); j_${recursionDepth}++) {
        #set($value = "nestedMap_${recursionDepth}")
        #set($recursionDepth = $recursionDepth + 1)
        #set($shapeMember = $template.nestedShapeMember)
        #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeMapValue.vm")
        #set($recursionDepth = $recursionDepth - 1)
        }

      }
      else // IndefMapStart
      {
        decoder->ConsumeNextSingleElement(); // consume the IndefMapStart
        while (decoder->LastError() == AWS_ERROR_UNKNOWN)
        {
          auto nextType_${recursionDepth} = decoder->PeekType();
          if (!nextType_${recursionDepth}.has_value() || nextType_${recursionDepth}.value() == CborType::Break)
          {
            if (nextType_${recursionDepth}.has_value())
            {
              decoder->ConsumeNextSingleElement(); // consume the Break
            }
            break;
          }
          #set($value = "nestedMap_${recursionDepth}")
          #set($recursionDepth = $recursionDepth + 1)
          #set($shapeMember = $template.nestedShapeMember)
          #parse("com/amazonaws/util/awsclientgenerator/velocity/cpp/cbor/CborDecodeMapValue.vm")
          #set($recursionDepth = $recursionDepth - 1)
        }
      }
      #if($recursionDepth > 1)
        #set($parentDepth = $recursionDepth - 1)
        nestedList_${parentDepth}.push_back(${value});
      #else
      ${memberVarName}.push_back(nestedMap_${recursionDepth});
      #end
    }
#else
auto peekType_${recursionDepth} = decoder->PeekType();
if(peekType_${recursionDepth}.has_value()){
    if(peekType_${recursionDepth}.value() == Aws::Crt::Cbor::CborType::UInt){
        auto ${containerVar} = decoder->PopNextUnsignedIntVal();
        if (${containerVar}.has_value()) {
            ${value}.push_back(static_cast<int64_t>(${containerVar}.value()));
        }
    } else {
        auto ${containerVar} = decoder->PopNextNegativeIntVal();
        if (${containerVar}.has_value()) {
            ${value}.push_back(static_cast<int64_t>(1 - ${containerVar}.value()));
        }
    }
}
#end