/**
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

#pragma once
#include <aws/neptunedata/Neptunedata_EXPORTS.h>
#include <aws/neptunedata/NeptunedataRequest.h>
#include <aws/core/utils/memory/stl/AWSString.h>
#include <aws/core/utils/memory/stl/AWSVector.h>
#include <aws/neptunedata/model/CustomModelTrainingParameters.h>
#include <utility>

namespace Aws
{
namespace neptunedata
{
namespace Model
{

  /**
   */
  class StartMLModelTrainingJobRequest : public NeptunedataRequest
  {
  public:
    AWS_NEPTUNEDATA_API StartMLModelTrainingJobRequest();

    // Service request name is the Operation name which will send this request out,
    // each operation should has unique request name, so that we can get operation's name from this request.
    // Note: this is not true for response, multiple operations may have the same response name,
    // so we can not get operation's name from response.
    inline virtual const char* GetServiceRequestName() const override { return "StartMLModelTrainingJob"; }

    AWS_NEPTUNEDATA_API Aws::String SerializePayload() const override;


    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline const Aws::String& GetId() const{ return m_id; }

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline bool IdHasBeenSet() const { return m_idHasBeenSet; }

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline void SetId(const Aws::String& value) { m_idHasBeenSet = true; m_id = value; }

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline void SetId(Aws::String&& value) { m_idHasBeenSet = true; m_id = std::move(value); }

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline void SetId(const char* value) { m_idHasBeenSet = true; m_id.assign(value); }

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline StartMLModelTrainingJobRequest& WithId(const Aws::String& value) { SetId(value); return *this;}

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline StartMLModelTrainingJobRequest& WithId(Aws::String&& value) { SetId(std::move(value)); return *this;}

    /**
     * <p>A unique identifier for the new job. The default is An autogenerated
     * UUID.</p>
     */
    inline StartMLModelTrainingJobRequest& WithId(const char* value) { SetId(value); return *this;}


    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline const Aws::String& GetPreviousModelTrainingJobId() const{ return m_previousModelTrainingJobId; }

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline bool PreviousModelTrainingJobIdHasBeenSet() const { return m_previousModelTrainingJobIdHasBeenSet; }

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline void SetPreviousModelTrainingJobId(const Aws::String& value) { m_previousModelTrainingJobIdHasBeenSet = true; m_previousModelTrainingJobId = value; }

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline void SetPreviousModelTrainingJobId(Aws::String&& value) { m_previousModelTrainingJobIdHasBeenSet = true; m_previousModelTrainingJobId = std::move(value); }

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline void SetPreviousModelTrainingJobId(const char* value) { m_previousModelTrainingJobIdHasBeenSet = true; m_previousModelTrainingJobId.assign(value); }

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline StartMLModelTrainingJobRequest& WithPreviousModelTrainingJobId(const Aws::String& value) { SetPreviousModelTrainingJobId(value); return *this;}

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline StartMLModelTrainingJobRequest& WithPreviousModelTrainingJobId(Aws::String&& value) { SetPreviousModelTrainingJobId(std::move(value)); return *this;}

    /**
     * <p>The job ID of a completed model-training job that you want to update
     * incrementally based on updated data.</p>
     */
    inline StartMLModelTrainingJobRequest& WithPreviousModelTrainingJobId(const char* value) { SetPreviousModelTrainingJobId(value); return *this;}


    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline const Aws::String& GetDataProcessingJobId() const{ return m_dataProcessingJobId; }

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline bool DataProcessingJobIdHasBeenSet() const { return m_dataProcessingJobIdHasBeenSet; }

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline void SetDataProcessingJobId(const Aws::String& value) { m_dataProcessingJobIdHasBeenSet = true; m_dataProcessingJobId = value; }

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline void SetDataProcessingJobId(Aws::String&& value) { m_dataProcessingJobIdHasBeenSet = true; m_dataProcessingJobId = std::move(value); }

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline void SetDataProcessingJobId(const char* value) { m_dataProcessingJobIdHasBeenSet = true; m_dataProcessingJobId.assign(value); }

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline StartMLModelTrainingJobRequest& WithDataProcessingJobId(const Aws::String& value) { SetDataProcessingJobId(value); return *this;}

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline StartMLModelTrainingJobRequest& WithDataProcessingJobId(Aws::String&& value) { SetDataProcessingJobId(std::move(value)); return *this;}

    /**
     * <p>The job ID of the completed data-processing job that has created the data
     * that the training will work with.</p>
     */
    inline StartMLModelTrainingJobRequest& WithDataProcessingJobId(const char* value) { SetDataProcessingJobId(value); return *this;}


    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline const Aws::String& GetTrainModelS3Location() const{ return m_trainModelS3Location; }

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline bool TrainModelS3LocationHasBeenSet() const { return m_trainModelS3LocationHasBeenSet; }

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline void SetTrainModelS3Location(const Aws::String& value) { m_trainModelS3LocationHasBeenSet = true; m_trainModelS3Location = value; }

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline void SetTrainModelS3Location(Aws::String&& value) { m_trainModelS3LocationHasBeenSet = true; m_trainModelS3Location = std::move(value); }

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline void SetTrainModelS3Location(const char* value) { m_trainModelS3LocationHasBeenSet = true; m_trainModelS3Location.assign(value); }

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainModelS3Location(const Aws::String& value) { SetTrainModelS3Location(value); return *this;}

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainModelS3Location(Aws::String&& value) { SetTrainModelS3Location(std::move(value)); return *this;}

    /**
     * <p>The location in Amazon S3 where the model artifacts are to be stored.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainModelS3Location(const char* value) { SetTrainModelS3Location(value); return *this;}


    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline const Aws::String& GetSagemakerIamRoleArn() const{ return m_sagemakerIamRoleArn; }

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline bool SagemakerIamRoleArnHasBeenSet() const { return m_sagemakerIamRoleArnHasBeenSet; }

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline void SetSagemakerIamRoleArn(const Aws::String& value) { m_sagemakerIamRoleArnHasBeenSet = true; m_sagemakerIamRoleArn = value; }

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline void SetSagemakerIamRoleArn(Aws::String&& value) { m_sagemakerIamRoleArnHasBeenSet = true; m_sagemakerIamRoleArn = std::move(value); }

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline void SetSagemakerIamRoleArn(const char* value) { m_sagemakerIamRoleArnHasBeenSet = true; m_sagemakerIamRoleArn.assign(value); }

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSagemakerIamRoleArn(const Aws::String& value) { SetSagemakerIamRoleArn(value); return *this;}

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSagemakerIamRoleArn(Aws::String&& value) { SetSagemakerIamRoleArn(std::move(value)); return *this;}

    /**
     * <p>The ARN of an IAM role for SageMaker execution.This must be listed in your DB
     * cluster parameter group or an error will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSagemakerIamRoleArn(const char* value) { SetSagemakerIamRoleArn(value); return *this;}


    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline const Aws::String& GetNeptuneIamRoleArn() const{ return m_neptuneIamRoleArn; }

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline bool NeptuneIamRoleArnHasBeenSet() const { return m_neptuneIamRoleArnHasBeenSet; }

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline void SetNeptuneIamRoleArn(const Aws::String& value) { m_neptuneIamRoleArnHasBeenSet = true; m_neptuneIamRoleArn = value; }

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline void SetNeptuneIamRoleArn(Aws::String&& value) { m_neptuneIamRoleArnHasBeenSet = true; m_neptuneIamRoleArn = std::move(value); }

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline void SetNeptuneIamRoleArn(const char* value) { m_neptuneIamRoleArnHasBeenSet = true; m_neptuneIamRoleArn.assign(value); }

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithNeptuneIamRoleArn(const Aws::String& value) { SetNeptuneIamRoleArn(value); return *this;}

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithNeptuneIamRoleArn(Aws::String&& value) { SetNeptuneIamRoleArn(std::move(value)); return *this;}

    /**
     * <p>The ARN of an IAM role that provides Neptune access to SageMaker and Amazon
     * S3 resources. This must be listed in your DB cluster parameter group or an error
     * will occur.</p>
     */
    inline StartMLModelTrainingJobRequest& WithNeptuneIamRoleArn(const char* value) { SetNeptuneIamRoleArn(value); return *this;}


    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline const Aws::String& GetBaseProcessingInstanceType() const{ return m_baseProcessingInstanceType; }

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline bool BaseProcessingInstanceTypeHasBeenSet() const { return m_baseProcessingInstanceTypeHasBeenSet; }

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline void SetBaseProcessingInstanceType(const Aws::String& value) { m_baseProcessingInstanceTypeHasBeenSet = true; m_baseProcessingInstanceType = value; }

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline void SetBaseProcessingInstanceType(Aws::String&& value) { m_baseProcessingInstanceTypeHasBeenSet = true; m_baseProcessingInstanceType = std::move(value); }

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline void SetBaseProcessingInstanceType(const char* value) { m_baseProcessingInstanceTypeHasBeenSet = true; m_baseProcessingInstanceType.assign(value); }

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline StartMLModelTrainingJobRequest& WithBaseProcessingInstanceType(const Aws::String& value) { SetBaseProcessingInstanceType(value); return *this;}

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline StartMLModelTrainingJobRequest& WithBaseProcessingInstanceType(Aws::String&& value) { SetBaseProcessingInstanceType(std::move(value)); return *this;}

    /**
     * <p>The type of ML instance used in preparing and managing training of ML models.
     * This is a CPU instance chosen based on memory requirements for processing the
     * training data and model.</p>
     */
    inline StartMLModelTrainingJobRequest& WithBaseProcessingInstanceType(const char* value) { SetBaseProcessingInstanceType(value); return *this;}


    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline const Aws::String& GetTrainingInstanceType() const{ return m_trainingInstanceType; }

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline bool TrainingInstanceTypeHasBeenSet() const { return m_trainingInstanceTypeHasBeenSet; }

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline void SetTrainingInstanceType(const Aws::String& value) { m_trainingInstanceTypeHasBeenSet = true; m_trainingInstanceType = value; }

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline void SetTrainingInstanceType(Aws::String&& value) { m_trainingInstanceTypeHasBeenSet = true; m_trainingInstanceType = std::move(value); }

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline void SetTrainingInstanceType(const char* value) { m_trainingInstanceTypeHasBeenSet = true; m_trainingInstanceType.assign(value); }

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainingInstanceType(const Aws::String& value) { SetTrainingInstanceType(value); return *this;}

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainingInstanceType(Aws::String&& value) { SetTrainingInstanceType(std::move(value)); return *this;}

    /**
     * <p>The type of ML instance used for model training. All Neptune ML models
     * support CPU, GPU, and multiGPU training. The default is
     * <code>ml.p3.2xlarge</code>. Choosing the right instance type for training
     * depends on the task type, graph size, and your budget.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainingInstanceType(const char* value) { SetTrainingInstanceType(value); return *this;}


    /**
     * <p>The disk volume size of the training instance. Both input data and the output
     * model are stored on disk, so the volume size must be large enough to hold both
     * data sets. The default is 0. If not specified or 0, Neptune ML selects a disk
     * volume size based on the recommendation generated in the data processing
     * step.</p>
     */
    inline int GetTrainingInstanceVolumeSizeInGB() const{ return m_trainingInstanceVolumeSizeInGB; }

    /**
     * <p>The disk volume size of the training instance. Both input data and the output
     * model are stored on disk, so the volume size must be large enough to hold both
     * data sets. The default is 0. If not specified or 0, Neptune ML selects a disk
     * volume size based on the recommendation generated in the data processing
     * step.</p>
     */
    inline bool TrainingInstanceVolumeSizeInGBHasBeenSet() const { return m_trainingInstanceVolumeSizeInGBHasBeenSet; }

    /**
     * <p>The disk volume size of the training instance. Both input data and the output
     * model are stored on disk, so the volume size must be large enough to hold both
     * data sets. The default is 0. If not specified or 0, Neptune ML selects a disk
     * volume size based on the recommendation generated in the data processing
     * step.</p>
     */
    inline void SetTrainingInstanceVolumeSizeInGB(int value) { m_trainingInstanceVolumeSizeInGBHasBeenSet = true; m_trainingInstanceVolumeSizeInGB = value; }

    /**
     * <p>The disk volume size of the training instance. Both input data and the output
     * model are stored on disk, so the volume size must be large enough to hold both
     * data sets. The default is 0. If not specified or 0, Neptune ML selects a disk
     * volume size based on the recommendation generated in the data processing
     * step.</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainingInstanceVolumeSizeInGB(int value) { SetTrainingInstanceVolumeSizeInGB(value); return *this;}


    /**
     * <p>Timeout in seconds for the training job. The default is 86,400 (1 day).</p>
     */
    inline int GetTrainingTimeOutInSeconds() const{ return m_trainingTimeOutInSeconds; }

    /**
     * <p>Timeout in seconds for the training job. The default is 86,400 (1 day).</p>
     */
    inline bool TrainingTimeOutInSecondsHasBeenSet() const { return m_trainingTimeOutInSecondsHasBeenSet; }

    /**
     * <p>Timeout in seconds for the training job. The default is 86,400 (1 day).</p>
     */
    inline void SetTrainingTimeOutInSeconds(int value) { m_trainingTimeOutInSecondsHasBeenSet = true; m_trainingTimeOutInSeconds = value; }

    /**
     * <p>Timeout in seconds for the training job. The default is 86,400 (1 day).</p>
     */
    inline StartMLModelTrainingJobRequest& WithTrainingTimeOutInSeconds(int value) { SetTrainingTimeOutInSeconds(value); return *this;}


    /**
     * <p>Maximum total number of training jobs to start for the hyperparameter tuning
     * job. The default is 2. Neptune ML automatically tunes the hyperparameters of the
     * machine learning model. To obtain a model that performs well, use at least 10
     * jobs (in other words, set <code>maxHPONumberOfTrainingJobs</code> to 10). In
     * general, the more tuning runs, the better the results.</p>
     */
    inline int GetMaxHPONumberOfTrainingJobs() const{ return m_maxHPONumberOfTrainingJobs; }

    /**
     * <p>Maximum total number of training jobs to start for the hyperparameter tuning
     * job. The default is 2. Neptune ML automatically tunes the hyperparameters of the
     * machine learning model. To obtain a model that performs well, use at least 10
     * jobs (in other words, set <code>maxHPONumberOfTrainingJobs</code> to 10). In
     * general, the more tuning runs, the better the results.</p>
     */
    inline bool MaxHPONumberOfTrainingJobsHasBeenSet() const { return m_maxHPONumberOfTrainingJobsHasBeenSet; }

    /**
     * <p>Maximum total number of training jobs to start for the hyperparameter tuning
     * job. The default is 2. Neptune ML automatically tunes the hyperparameters of the
     * machine learning model. To obtain a model that performs well, use at least 10
     * jobs (in other words, set <code>maxHPONumberOfTrainingJobs</code> to 10). In
     * general, the more tuning runs, the better the results.</p>
     */
    inline void SetMaxHPONumberOfTrainingJobs(int value) { m_maxHPONumberOfTrainingJobsHasBeenSet = true; m_maxHPONumberOfTrainingJobs = value; }

    /**
     * <p>Maximum total number of training jobs to start for the hyperparameter tuning
     * job. The default is 2. Neptune ML automatically tunes the hyperparameters of the
     * machine learning model. To obtain a model that performs well, use at least 10
     * jobs (in other words, set <code>maxHPONumberOfTrainingJobs</code> to 10). In
     * general, the more tuning runs, the better the results.</p>
     */
    inline StartMLModelTrainingJobRequest& WithMaxHPONumberOfTrainingJobs(int value) { SetMaxHPONumberOfTrainingJobs(value); return *this;}


    /**
     * <p>Maximum number of parallel training jobs to start for the hyperparameter
     * tuning job. The default is 2. The number of parallel jobs you can run is limited
     * by the available resources on your training instance.</p>
     */
    inline int GetMaxHPOParallelTrainingJobs() const{ return m_maxHPOParallelTrainingJobs; }

    /**
     * <p>Maximum number of parallel training jobs to start for the hyperparameter
     * tuning job. The default is 2. The number of parallel jobs you can run is limited
     * by the available resources on your training instance.</p>
     */
    inline bool MaxHPOParallelTrainingJobsHasBeenSet() const { return m_maxHPOParallelTrainingJobsHasBeenSet; }

    /**
     * <p>Maximum number of parallel training jobs to start for the hyperparameter
     * tuning job. The default is 2. The number of parallel jobs you can run is limited
     * by the available resources on your training instance.</p>
     */
    inline void SetMaxHPOParallelTrainingJobs(int value) { m_maxHPOParallelTrainingJobsHasBeenSet = true; m_maxHPOParallelTrainingJobs = value; }

    /**
     * <p>Maximum number of parallel training jobs to start for the hyperparameter
     * tuning job. The default is 2. The number of parallel jobs you can run is limited
     * by the available resources on your training instance.</p>
     */
    inline StartMLModelTrainingJobRequest& WithMaxHPOParallelTrainingJobs(int value) { SetMaxHPOParallelTrainingJobs(value); return *this;}


    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline const Aws::Vector<Aws::String>& GetSubnets() const{ return m_subnets; }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline bool SubnetsHasBeenSet() const { return m_subnetsHasBeenSet; }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline void SetSubnets(const Aws::Vector<Aws::String>& value) { m_subnetsHasBeenSet = true; m_subnets = value; }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline void SetSubnets(Aws::Vector<Aws::String>&& value) { m_subnetsHasBeenSet = true; m_subnets = std::move(value); }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSubnets(const Aws::Vector<Aws::String>& value) { SetSubnets(value); return *this;}

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSubnets(Aws::Vector<Aws::String>&& value) { SetSubnets(std::move(value)); return *this;}

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSubnets(const Aws::String& value) { m_subnetsHasBeenSet = true; m_subnets.push_back(value); return *this; }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSubnets(Aws::String&& value) { m_subnetsHasBeenSet = true; m_subnets.push_back(std::move(value)); return *this; }

    /**
     * <p>The IDs of the subnets in the Neptune VPC. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSubnets(const char* value) { m_subnetsHasBeenSet = true; m_subnets.push_back(value); return *this; }


    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline const Aws::Vector<Aws::String>& GetSecurityGroupIds() const{ return m_securityGroupIds; }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline bool SecurityGroupIdsHasBeenSet() const { return m_securityGroupIdsHasBeenSet; }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline void SetSecurityGroupIds(const Aws::Vector<Aws::String>& value) { m_securityGroupIdsHasBeenSet = true; m_securityGroupIds = value; }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline void SetSecurityGroupIds(Aws::Vector<Aws::String>&& value) { m_securityGroupIdsHasBeenSet = true; m_securityGroupIds = std::move(value); }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSecurityGroupIds(const Aws::Vector<Aws::String>& value) { SetSecurityGroupIds(value); return *this;}

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithSecurityGroupIds(Aws::Vector<Aws::String>&& value) { SetSecurityGroupIds(std::move(value)); return *this;}

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSecurityGroupIds(const Aws::String& value) { m_securityGroupIdsHasBeenSet = true; m_securityGroupIds.push_back(value); return *this; }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSecurityGroupIds(Aws::String&& value) { m_securityGroupIdsHasBeenSet = true; m_securityGroupIds.push_back(std::move(value)); return *this; }

    /**
     * <p>The VPC security group IDs. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& AddSecurityGroupIds(const char* value) { m_securityGroupIdsHasBeenSet = true; m_securityGroupIds.push_back(value); return *this; }


    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline const Aws::String& GetVolumeEncryptionKMSKey() const{ return m_volumeEncryptionKMSKey; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline bool VolumeEncryptionKMSKeyHasBeenSet() const { return m_volumeEncryptionKMSKeyHasBeenSet; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline void SetVolumeEncryptionKMSKey(const Aws::String& value) { m_volumeEncryptionKMSKeyHasBeenSet = true; m_volumeEncryptionKMSKey = value; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline void SetVolumeEncryptionKMSKey(Aws::String&& value) { m_volumeEncryptionKMSKeyHasBeenSet = true; m_volumeEncryptionKMSKey = std::move(value); }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline void SetVolumeEncryptionKMSKey(const char* value) { m_volumeEncryptionKMSKeyHasBeenSet = true; m_volumeEncryptionKMSKey.assign(value); }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithVolumeEncryptionKMSKey(const Aws::String& value) { SetVolumeEncryptionKMSKey(value); return *this;}

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithVolumeEncryptionKMSKey(Aws::String&& value) { SetVolumeEncryptionKMSKey(std::move(value)); return *this;}

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * data on the storage volume attached to the ML compute instances that run the
     * training job. The default is None.</p>
     */
    inline StartMLModelTrainingJobRequest& WithVolumeEncryptionKMSKey(const char* value) { SetVolumeEncryptionKMSKey(value); return *this;}


    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline const Aws::String& GetS3OutputEncryptionKMSKey() const{ return m_s3OutputEncryptionKMSKey; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline bool S3OutputEncryptionKMSKeyHasBeenSet() const { return m_s3OutputEncryptionKMSKeyHasBeenSet; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline void SetS3OutputEncryptionKMSKey(const Aws::String& value) { m_s3OutputEncryptionKMSKeyHasBeenSet = true; m_s3OutputEncryptionKMSKey = value; }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline void SetS3OutputEncryptionKMSKey(Aws::String&& value) { m_s3OutputEncryptionKMSKeyHasBeenSet = true; m_s3OutputEncryptionKMSKey = std::move(value); }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline void SetS3OutputEncryptionKMSKey(const char* value) { m_s3OutputEncryptionKMSKeyHasBeenSet = true; m_s3OutputEncryptionKMSKey.assign(value); }

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline StartMLModelTrainingJobRequest& WithS3OutputEncryptionKMSKey(const Aws::String& value) { SetS3OutputEncryptionKMSKey(value); return *this;}

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline StartMLModelTrainingJobRequest& WithS3OutputEncryptionKMSKey(Aws::String&& value) { SetS3OutputEncryptionKMSKey(std::move(value)); return *this;}

    /**
     * <p>The Amazon Key Management Service (KMS) key that SageMaker uses to encrypt
     * the output of the processing job. The default is none.</p>
     */
    inline StartMLModelTrainingJobRequest& WithS3OutputEncryptionKMSKey(const char* value) { SetS3OutputEncryptionKMSKey(value); return *this;}


    /**
     * <p>Optimizes the cost of training machine-learning models by using Amazon
     * Elastic Compute Cloud spot instances. The default is <code>False</code>.</p>
     */
    inline bool GetEnableManagedSpotTraining() const{ return m_enableManagedSpotTraining; }

    /**
     * <p>Optimizes the cost of training machine-learning models by using Amazon
     * Elastic Compute Cloud spot instances. The default is <code>False</code>.</p>
     */
    inline bool EnableManagedSpotTrainingHasBeenSet() const { return m_enableManagedSpotTrainingHasBeenSet; }

    /**
     * <p>Optimizes the cost of training machine-learning models by using Amazon
     * Elastic Compute Cloud spot instances. The default is <code>False</code>.</p>
     */
    inline void SetEnableManagedSpotTraining(bool value) { m_enableManagedSpotTrainingHasBeenSet = true; m_enableManagedSpotTraining = value; }

    /**
     * <p>Optimizes the cost of training machine-learning models by using Amazon
     * Elastic Compute Cloud spot instances. The default is <code>False</code>.</p>
     */
    inline StartMLModelTrainingJobRequest& WithEnableManagedSpotTraining(bool value) { SetEnableManagedSpotTraining(value); return *this;}


    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline const CustomModelTrainingParameters& GetCustomModelTrainingParameters() const{ return m_customModelTrainingParameters; }

    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline bool CustomModelTrainingParametersHasBeenSet() const { return m_customModelTrainingParametersHasBeenSet; }

    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline void SetCustomModelTrainingParameters(const CustomModelTrainingParameters& value) { m_customModelTrainingParametersHasBeenSet = true; m_customModelTrainingParameters = value; }

    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline void SetCustomModelTrainingParameters(CustomModelTrainingParameters&& value) { m_customModelTrainingParametersHasBeenSet = true; m_customModelTrainingParameters = std::move(value); }

    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline StartMLModelTrainingJobRequest& WithCustomModelTrainingParameters(const CustomModelTrainingParameters& value) { SetCustomModelTrainingParameters(value); return *this;}

    /**
     * <p>The configuration for custom model training. This is a JSON object.</p>
     */
    inline StartMLModelTrainingJobRequest& WithCustomModelTrainingParameters(CustomModelTrainingParameters&& value) { SetCustomModelTrainingParameters(std::move(value)); return *this;}

  private:

    Aws::String m_id;
    bool m_idHasBeenSet = false;

    Aws::String m_previousModelTrainingJobId;
    bool m_previousModelTrainingJobIdHasBeenSet = false;

    Aws::String m_dataProcessingJobId;
    bool m_dataProcessingJobIdHasBeenSet = false;

    Aws::String m_trainModelS3Location;
    bool m_trainModelS3LocationHasBeenSet = false;

    Aws::String m_sagemakerIamRoleArn;
    bool m_sagemakerIamRoleArnHasBeenSet = false;

    Aws::String m_neptuneIamRoleArn;
    bool m_neptuneIamRoleArnHasBeenSet = false;

    Aws::String m_baseProcessingInstanceType;
    bool m_baseProcessingInstanceTypeHasBeenSet = false;

    Aws::String m_trainingInstanceType;
    bool m_trainingInstanceTypeHasBeenSet = false;

    int m_trainingInstanceVolumeSizeInGB;
    bool m_trainingInstanceVolumeSizeInGBHasBeenSet = false;

    int m_trainingTimeOutInSeconds;
    bool m_trainingTimeOutInSecondsHasBeenSet = false;

    int m_maxHPONumberOfTrainingJobs;
    bool m_maxHPONumberOfTrainingJobsHasBeenSet = false;

    int m_maxHPOParallelTrainingJobs;
    bool m_maxHPOParallelTrainingJobsHasBeenSet = false;

    Aws::Vector<Aws::String> m_subnets;
    bool m_subnetsHasBeenSet = false;

    Aws::Vector<Aws::String> m_securityGroupIds;
    bool m_securityGroupIdsHasBeenSet = false;

    Aws::String m_volumeEncryptionKMSKey;
    bool m_volumeEncryptionKMSKeyHasBeenSet = false;

    Aws::String m_s3OutputEncryptionKMSKey;
    bool m_s3OutputEncryptionKMSKeyHasBeenSet = false;

    bool m_enableManagedSpotTraining;
    bool m_enableManagedSpotTrainingHasBeenSet = false;

    CustomModelTrainingParameters m_customModelTrainingParameters;
    bool m_customModelTrainingParametersHasBeenSet = false;
  };

} // namespace Model
} // namespace neptunedata
} // namespace Aws
